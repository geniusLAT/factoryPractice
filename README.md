# factoryPractice

### описание от VK
VK продвигает сервисы, товары и услуги разнообразными способами. Одним из основных является реклама. Качественная реклама требует хорошего понимания аудитории. Вам предложен датасет. Необходимо предсказать пол человека.   Представьте, что вы работаете в бизнес-юните VK Реклама компании VK.
 
Приближаются праздники. Крупная компания, занимающаяся продажей подарочных наборов, хочет запустить рекламу подарков в соцсетях ВКонтакте, Одноклассники и Дзен. 
 
Вам нужно разработать модель машинного обучения, которая будет предсказывать пол пользователя соцсетей. Это необходимо, чтобы реклама была эффективной: демонстрировалась пользователям соответствующего гендера. 
 
Компания VK заинтересована в получении этого крупного заказа. Сотрудник, который представит модель машинного обучения, быстро и точно предсказывающую пол пользователя, получит вознаграждение.
 
В вашем распоряжении есть табличный датасет, на котором вы можете тренировать модели машинного обучения. У вас есть 4 часа и 10 попыток, чтобы разработать свой вариант модели машинного обучения.
Описание датасета
Таблицы

train_labels.csv: - «user_id» - id пользователя; - «target» - пол пользователя (1 / 0).  

train.csv, test.csv; - «request_ts» - server timestamp of request; - «user_id» - id пользователя (см. п.1); - «referer» - url, где показывается реклама. В данном случае захэшировано 2 части url: 1) domain - домен урла; 2) path - все что после domain. Например, https://a758bf6/1432d3f1, a 758bf6 - domain, 1432d3f1 - path. - «geo_id» - id geo; - «user_agent» - строка user_agent. 
 
referer_vectors.csv: - «component0» - … - «component9» - числа, которые несут в себе информацию о url. Их нельзя как-либо интерпретировать; - «referer» - url, где показывается реклама (см. п.2).  

geo_info.csv: - «geo_id» - id geo (см. п.2); - «country_id» - id страны; - «region_id» - id региона; - «timezone» - часовой пояс для geo.

Требования Для каждого пользователя (user) из файла test_users.csv необходимо предсказать пол. Их рекламные запросы лежат в файле test.csv.  Формат вывода Формат вывода соответствует train_labels.csv.


## План

Для начала надо понять какие данные мы хотим видеть на входе. У нас есть тестовые данные и сначала мы обкатываем алгоритм на них. Когда на них работает хорошо мы делаем хорошо и для других данных. Это очень напоминает лабораторную работу про молдавские машины.

Формат ответа :
- user_id
- target   

Теперь надо пооткрывать файлики и посмотреть, какие факторы мы можем разместить на входе. Так у нас получатся коэфициенты корреляции. Мы не трогаем файлы test.csv и test_users.csv, так как они относятся к самому заданию, а не к тренировке, так что для таких файлов мы это игнорируем.

Очевидно, что предполагается предсказание по такому же набору данных как в test.csv. Надо найти в тренировочной выборке файл, аналогичный файлу test.csv, то есть такой, где в шапке будут указаны request_ts;user_id;referer;geo_id;user_agent

Мы можем заметить, что файл train.csv имеет абсолютно аналогичную шапку. То есть данные из него будут использоваться на тренировочной выборке. Мы имеем возможность связать его с user_id из train_labels.

Предварительный формат входного вектора:
 - request_ts (из файла train.csv или test.csv)
 - user_id    (из файла train.csv или test.csv)
 - referer    (из файла train.csv или test.csv)
 - geo_id     (из файла train.csv или test.csv)
 - user_agent (из файла train.csv или test.csv)

 У нас не всё можно подать в таком необработанном виде на вход, часть из этих данных будет использоваться не более чем ссылка, а user_agent мы потенциально собираемся распарсить на 4 составляющих и сделать с ними ряд магических действий.

 Обратим внимание на два файла, которые были нам выданы, но мы пока в них не заглядывали. Это referer_vectors.csv и geo_info.csv. Откроем geo_info.csv.

Столбцы файла geo_info.csv
 - geo_id
 - country_id
 - region_id
 - timezone_id
 
Мы можем видеть здесь идентификатор государства, региона и часового пояса. Сам geo_id будет с высокой вероятностью уникален и найденные коэфициенты корреляции не особо будут
влиять на новые значения, так что geo_id будет использован для соединения user_id и трёх столбцов из geo_info.

Предварительный формат входного вектора:
 - request_ts   (из файла train.csv или test.csv)
 - user_id      (из файла train.csv или test.csv)
 - referer      (из файла train.csv или test.csv)
 - country_id   (из файла geo_info.csv)
 - region_id    (из файла geo_info.csv)
 - timezone_id  (из файла geo_info.csv)
 - user_agent   (из файла train.csv или test.csv)

 Интересный вопрос. А является ли файл geo_info.csv общим и для тестовой и для тренировочной выборки. 

 Проверка 1: возьму три случайных geo_id из train.csv и найду запись для них.
 Результат: Найдено.

  Проверка 2: возьму три случайных geo_id из test.csv и найду запись для них.
 Результат: Найдено.

 Мы приходим к выводу, что данные из geo_info.csv являются смешанными для двух выборок.

 Теперь нас интересуют referer_vectors.csv. Откроем файл и взглянем на шапку.
 - component0
 - component1
 - component2 
 - component3
 - component4
 - component5
 - component6
 - component7
 - component8
 - component9
 - referer

 Мы аналогично можем связать по пункту referer эти 10 компонентов. Компоненты явно не представляют интереса как цифры, хотя таковыми и являются и мы отметим их как качественные параметры.

 Проверим, что по 3 случайных referer из обоих файлов ссылаются на referer_vectors.csv.
 Успешно. Отдельно отмечу, что path для некоторых записей был утерян. Не понятно это
 аномалия с потерей данных или так и задумано и просто не хешируется path по умолчанию.
 Отложим этот вопрос. На данном этапе у нас получается

 Предварительный формат входного вектора:
 - request_ts   (из файла train.csv или test.csv)
 - user_id      (из файла train.csv или test.csv)
 - component0   (из файла referer_vectors.csv)
 - component1   (из файла referer_vectors.csv)
 - component2   (из файла referer_vectors.csv) 
 - component3   (из файла referer_vectors.csv)
 - component4   (из файла referer_vectors.csv)
 - component5   (из файла referer_vectors.csv)
 - component6   (из файла referer_vectors.csv)
 - component7   (из файла referer_vectors.csv)
 - component8   (из файла referer_vectors.csv)
 - component9   (из файла referer_vectors.csv)
 - country_id   (из файла geo_info.csv)
 - region_id    (из файла geo_info.csv)
 - timezone_id  (из файла geo_info.csv)
 - user_agent   (из файла train.csv или test.csv)


 Теперь я предлагаю обратить наше внимание на поле user_agent. Приведу пример
 содержимого данного поля в одной из записей
 *{'browser': 'Yandex Browser', 'browser_version': '23.9.5', 'os': 'Windows','os_version': '10'}*

 У нас есть пары ключ значение, приведу исключительно ключи.
 - browser
 - browser_version
 - os
 - os_version

 Мы могли бы добавить в общий формат данные в таком формате, но тут возникает один вопрос, который требует боле тщательного обдумывания. Версии разных браузеров и версии операционных систем значат разные вещи. Так что мы не можем представить их как цифру, а потом ввести общий коэффициент кореляции. И мы на уровне гипотезы можем назвать некорректным высказывание "Мужчины чаще обновляются, поэтому чем больше цифра версии браузера или операционной системы, тем выше вероятность, что это мужчина". 

 Для начала версии это не всегда цифры, иногда это иногда 3 цифры через делимитр (точку). Но даже опустив этот аспект мы не можем так делать. Мы должны понимать,
 насколько это новая или не новая версия. И версия яндекса 23 может считаться новой,
 а версия хрома 108 старой. Потому что эти цифры между собой не связаны.

 Так что с этим надо что-то сделать. 

 #### Идея 1
 Мы пишем отдельный модуль, который переводит версию в года. А уже из годов понимать,
 насколько человек на новой версии сидит. По прежнему есть ньюансы, так как
 можно допустить, что могут возникнуть ситуации, когда мы сравним человека на
 Android и Windows, и версии Windows просто выпускаются реже. Так люди в одинаковой
 степени приверженцы всего нового, но у одного версия OS более позднего года,
 потому что Android получил в этот год новую версию, а Windows нет.

 #### Идея 2
 Мы делаем отдельные параметры с версиями как качественным, не количественным параметром. Потому что мы можем допустить, что выбор той или иной версии сопряжён
 с некий социо-культурным контекстом, который имеет кореляциию с гендером. 
 Пример гипотезы: в мужской среде более распространена Windows 7 из-за
 некоторой репутации именно этой версии.

 В идеале - воплотить две идеи и посмотреть, какая будет работать больше.
 Но в предварительной версии мы откинем номера версий, но оставлю браузеры
и операционные системы.

Позднее мы вернёмся и реализуем одну или обе эти идеи (если вы не видите реализации - нам стало лень).

 Предварительный формат входного вектора:
 - request_ts                   (из файла train.csv или test.csv)
 - user_id                      (из файла train.csv или test.csv)
 - component0                   (из файла referer_vectors.csv)
 - component1                   (из файла referer_vectors.csv)
 - component2                   (из файла referer_vectors.csv) 
 - component3                   (из файла referer_vectors.csv)
 - component4                   (из файла referer_vectors.csv)
 - component5                   (из файла referer_vectors.csv)
 - component6                   (из файла referer_vectors.csv)
 - component7                   (из файла referer_vectors.csv)
 - component8                   (из файла referer_vectors.csv)
 - component9                   (из файла referer_vectors.csv)
 - country_id                   (из файла geo_info.csv)
 - region_id                    (из файла geo_info.csv)
 - timezone_id                  (из файла geo_info.csv)
 - user_agent_browser           (из парсинга файла train.csv или test.csv )
 - user_agent_browser_version   (из парсинга файла train.csv или test.csv )
 - user_agent_os                (из парсинга файла train.csv или test.csv )
 - user_agent_os_version        (из парсинга файла train.csv или test.csv )

